using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Text;
using ICSharpCode.NRefactory.Ast;
using ICSharpCode.NRefactory.Parser.VB;
using ASTAttribute = ICSharpCode.NRefactory.Ast.Attribute;

PUSHCOMPILER ExpressionFinder

/* START AUTOGENERATED TOKENS SECTION */
TOKENS
	/* ----- terminal classes ----- */
	/* EOF is 0 */
	EOL
	ident
	LiteralString
	LiteralCharacter
	LiteralInteger
	LiteralDouble
	LiteralSingle
	LiteralDecimal
	LiteralDate
	XmlOpenTag
	XmlCloseTag
	XmlStartInlineVB
	XmlEndInlineVB
	XmlCloseTagEmptyElement
	XmlOpenEndTag
	XmlContent
	XmlComment
	XmlCData
	XmlProcessingInstructionStart
	XmlProcessingInstructionEnd

	/* ----- special character ----- */
	"="
	":"
	","
	"&"
	"/"
	"\\"
	"."
	"!"
	"-"
	"+"
	"^"
	"?"
	"*"
	"{"
	"}"
	"("
	")"
	">"
	"<"
	"<>"
	">="
	"<="
	"<<"
	">>"
	"+="
	"^="
	"-="
	"*="
	"/="
	"\\="
	"<<="
	">>="
	"&="
	":="

	/* ----- keywords ----- */
	"AddHandler"
	"AddressOf"
	"Aggregate"
	"Alias"
	"And"
	"AndAlso"
	"Ansi"
	"As"
	"Ascending"
	"Assembly"
	"Auto"
	"Binary"
	"Boolean"
	"ByRef"
	"By"
	"Byte"
	"ByVal"
	"Call"
	"Case"
	"Catch"
	"CBool"
	"CByte"
	"CChar"
	"CDate"
	"CDbl"
	"CDec"
	"Char"
	"CInt"
	"Class"
	"CLng"
	"CObj"
	"Compare"
	"Const"
	"Continue"
	"CSByte"
	"CShort"
	"CSng"
	"CStr"
	"CType"
	"CUInt"
	"CULng"
	"CUShort"
	"Custom"
	"Date"
	"Decimal"
	"Declare"
	"Default"
	"Delegate"
	"Descending"
	"Dim"
	"DirectCast"
	"Distinct"
	"Do"
	"Double"
	"Each"
	"Else"
	"ElseIf"
	"End"
	"EndIf"
	"Enum"
	"Equals"
	"Erase"
	"Error"
	"Event"
	"Exit"
	"Explicit"
	"False"
	"Finally"
	"For"
	"Friend"
	"From"
	"Function"
	"Get"
	"GetType"
	"Global"
	"GoSub"
	"GoTo"
	"Group"
	"Handles"
	"If"
	"Implements"
	"Imports"
	"In"
	"Infer"
	"Inherits"
	"Integer"
	"Interface"
	"Into"
	"Is"
	"IsNot"
	"Join"
	"Key"
	"Let"
	"Lib"
	"Like"
	"Long"
	"Loop"
	"Me"
	"Mod"
	"Module"
	"MustInherit"
	"MustOverride"
	"MyBase"
	"MyClass"
	"Namespace"
	"Narrowing"
	"New"
	"Next"
	"Not"
	"Nothing"
	"NotInheritable"
	"NotOverridable"
	"Object"
	"Of"
	"Off"
	"On"
	"Operator"
	"Option"
	"Optional"
	"Or"
	"Order"
	"OrElse"
	"Overloads"
	"Overridable"
	"Overrides"
	"ParamArray"
	"Partial"
	"Preserve"
	"Private"
	"Property"
	"Protected"
	"Public"
	"RaiseEvent"
	"ReadOnly"
	"ReDim"
	"Rem"
	"RemoveHandler"
	"Resume"
	"Return"
	"SByte"
	"Select"
	"Set"
	"Shadows"
	"Shared"
	"Short"
	"Single"
	"Skip"
	"Static"
	"Step"
	"Stop"
	"Strict"
	"String"
	"Structure"
	"Sub"
	"SyncLock"
	"Take"
	"Text"
	"Then"
	"Throw"
	"To"
	"True"
	"Try"
	"TryCast"
	"TypeOf"
	"UInteger"
	"ULong"
	"Unicode"
	"Until"
	"UShort"
	"Using"
	"Variant"
	"Wend"
	"When"
	"Where"
	"While"
	"Widening"
	"With"
	"WithEvents"
	"WriteOnly"
	"Xor"
	"GetXmlNamespace"
/* END AUTOGENERATED TOKENS SECTION */

PRODUCTIONS
/*------------------------------------------------------------------------*/
ExpressionFinder =
	(. PushContext(Context.Global, t); .)
	{ OptionStatement }
	{ ImportsStatement }
	{ AttributeBlock }
	{ NamespaceMemberDeclaration }
	(. PopContext(); .)
.

StatementTerminator = EOL | ":" .

OptionStatement = 
	"Option" { ANY } StatementTerminator
.

ImportsStatement = 
	"Imports" (. nextTokenIsPotentialStartOfXmlMode = true; .) { ANY } StatementTerminator
.

AttributeBlock =
	"<" (. PushContext(Context.Attribute, t); .) { ANY } ">" (. PopContext(); .) [ EOL ]
.

NamespaceMemberDeclaration =
	NamespaceDeclaration |
	TypeDeclaration
.

NamespaceDeclaration =
	"Namespace" { ANY } StatementTerminator
	{ NamespaceMemberDeclaration }
	"End" "Namespace" StatementTerminator
.

TypeDeclaration =
	{ AttributeBlock }
	{ TypeModifier }
	( "Module" |  "Class" ) { ANY } StatementTerminator
	(. PushContext(Context.Type, t); .)
	{ MemberDeclaration }
	"End" ( "Module" | "Class" ) StatementTerminator
	(. PopContext(); .)
.

MemberDeclaration =
	(. PushContext(Context.Member, t); .)
	{ AttributeBlock } { MemberModifier }
	(
		MemberVariableOrConstantDeclaration |
		SubOrFunctionDeclaration |
		ExternalMemberDeclaration |
		EventMemberDeclaration |
		CustomEventMemberDeclaration |
		OperatorDeclaration
	)
	(. PopContext(); .)
.

SubOrFunctionDeclaration = 
	("Sub" | "Function")
	(. PushContext(Context.IdentifierExpected, t); .) ANY (. PopContext(); .)
	[ "(" [ ParameterList ] ")" ] [ "As" TypeName ]
	StatementTerminatorAndBlock
	"End" ("Sub" | "Function") StatementTerminator
.

ExternalMemberDeclaration =
	"Declare" [ "Ansi" | "Unicode" | "Auto" ] ( "Sub" | "Function" ) Identifier
	"Lib" LiteralString [ "Alias" LiteralString ] [ "(" [ ParameterList ] ")" ] StatementTerminator
.

EventMemberDeclaration =
	"Event" Identifier ( "As" TypeName | [ "(" [ ParameterList ] ")" ] )
	[ "Implements" TypeName /*"." IdentifierOrKeyword*/ { "," TypeName /*"." IdentifierOrKeyword*/ } ]
	/* the TypeName production already allows the "." IdentifierOrKeyword syntax, so to avoid an ambiguous grammer we just leave that out */
	StatementTerminator
.

CustomEventMemberDeclaration =
	"Custom" EventMemberDeclaration
	{
		{ AttributeBlock } ( "AddHandler" | "RemoveHandler" | "RaiseEvent" ) "(" ParameterList ")"
		StatementTerminatorAndBlock
		"End" ( "AddHandler" | "RemoveHandler" | "RaiseEvent" ) StatementTerminator
	}
	"End" "Event" StatementTerminator
.

OperatorDeclaration =
	"Operator" ANY "(" ParameterList ")" [ "As" { AttributeBlock } TypeName ]
	StatementTerminatorAndBlock
	"End" "Operator" StatementTerminator
.

MemberVariableOrConstantDeclaration =
	[ "Const" ] IdentifierForFieldDeclaration [ "As" TypeName ] [ "=" Expression ] StatementTerminator
.

ParameterList =
	Parameter { "," Parameter }
.

Parameter =
	{ AttributeBlock } { ParameterModifier } Identifier [ "As" TypeName ] [ "=" Expression ] 
.

StatementTerminatorAndBlock =
	(. PushContext(Context.Body, t); .)
	StatementTerminator
	{ [ Statement] StatementTerminator }
	(. PopContext(); .)
.

Expression =
	(. nextTokenIsPotentialStartOfXmlMode = true; .)
	(
		SimpleExpressionWithSuffix { BinaryOperator SimpleExpressionWithSuffix }
		| ConditionalExpression
	)
.

BinaryOperator =
	"+" | "-" | "*" | "\\" | "/" | "^" | "Mod"
	| "=" | "<>" | "<" | ">" | "<=" | ">=" 
	| "Like" | "&" | "And" | "AndAlso" | "Or" | "OrElse"
	| "Xor" | "<<" | ">>" | "Is" | "IsNot"
	| "^=" | "*=" | "/=" | "\\=" | "+=" | "-=" | "&=" | "<<=" | ">>=" | "To" | ":="
.

UnaryOperator =
	"+" | "-" | "Not" | "AddressOf"
.

SimpleExpressionWithSuffix =
	(. nextTokenIsPotentialStartOfXmlMode = true; .)
	{ UnaryOperator }
	(
	   SimpleExpression { ExpressionSuffix }
	| "TypeOf" SimpleExpressionWithSuffix "Is" TypeName
	| NewExpression
	).

SimpleExpression =
    (. nextTokenIsPotentialStartOfXmlMode = true; .)
    (    Literal
    |    ( "(" Expression ")" )
    |    Identifier
    |    ( "." | "!" ) IdentifierOrKeyword
    |    "GetType" "(" TypeName ")"
    |    "GetXmlNamespace" "(" (. readXmlIdentifier = true; .) Identifier ")"
    |    XmlLiteral
    |    CastExpression
    )
.

NewExpression =
	"New" [ TypeName [ "From" CollectionInitializer ] ] [ "With" ObjectInitializer ]
.

ObjectInitializer =
	"{" [ "Key" ] "." IdentifierOrKeyword "=" Expression { "," [ "Key" ] "." IdentifierOrKeyword "=" Expression } "}"
.

CollectionInitializer =
	"{" ( Expression | CollectionInitializer ) { "," ( Expression | CollectionInitializer ) } "}"
.

ExpressionSuffix =
    "(" (. nextTokenIsPotentialStartOfXmlMode = true; .) ( "Of" TypeName { "," TypeName } ")" | ArgumentList ")" )
|    ( "." | "!" ) IdentifierOrKeyword
.

CastExpression =
	SimpleCastExpression | ("DirectCast" | "TryCast" | "CType") "(" Expression "," TypeName ")"
.

SimpleCastExpression =
	(
		"CBool"   |
		"CByte"   |
		"CChar"   |
		"CDate"   |
		"CDec"    |
		"CDbl"    |
		"CInt"    |
		"CLng"    |
		"CObj"    |
		"CSByte"  |
		"CShort"  |
		"CSng"    |
		"CStr"    |
		"CUInt"   |
		"CULng"   |
		"CUShort"
	)
	"(" Expression ")"
.

ConditionalExpression =
	"If" "(" Expression "," Expression [ "," Expression ] ")"
.

XmlLiteral =
    (. PushContext(Context.Xml, t); .)
    { XmlComment } XmlElement { XmlComment }
    (. PopContext(); .)
.

XmlElement =
	XmlOpenTag { ANY } ( XmlCloseTagEmptyElement | XmlCloseTag { ANY | XmlElement } XmlOpenEndTag { ANY } XmlCloseTag )
.

PrimitiveTypeName = 
	"Byte" |
    "SByte" |
    "UShort" |
    "Short" |
    "UInteger" |
    "Integer" |
    "ULong" |
    "Long" |
	"Single" |
	"Double" |
	"Decimal" |
	"Boolean" |
	"Date" |
	"Char" |
	"String" |
	"Object"
.
	
TypeName = ( "Global" | Identifier | PrimitiveTypeName ) { TypeSuffix } { "." IdentifierOrKeyword { TypeSuffix } } .

TypeSuffix = "(" ( "Of" [ TypeName ] { "," [ TypeName ] } | [ ArgumentList ] ) ")" .

IdentifierOrKeyword = ANY .

Literal =
	LiteralString |
	LiteralCharacter |
	LiteralInteger |
	LiteralDouble |
	LiteralSingle |
	LiteralDecimal |
	LiteralDate |
	"True" |
	"False" |
	"Nothing" |
	/* from InstanceExpression */
	"Me" |
	"MyBase" |
	"MyClass"
.

Statement =
	VariableDeclarationStatement
	| WithOrLockStatement
	| AddOrRemoveHandlerStatement
	| RaiseEventStatement
	| IfStatement
	| SelectStatement
	| InvocationStatement
.

VariableDeclarationStatement =
	( "Dim" | "Static" | "Const" ) Identifier [ "?" ] [ ( "(" { "," } ")" ) ] { "," Identifier [ "?" ] [ ( "(" { "," } ")" ) ] } [ "As" [ "New" ] TypeName ] [ "=" Expression ]
.

WithOrLockStatement =
	( "With" | "SyncLock" ) Expression StatementTerminatorAndBlock "End" ( "With" | "SyncLock" )
.

AddOrRemoveHandlerStatement =
	( "AddHandler" | "RemoveHandler" ) Expression "," Expression
.

RaiseEventStatement =
	"RaiseEvent" IdentifierOrKeyword [ "(" [ ArgumentList ] ")" ]
.

IfStatement =
    "If" Expression
    (    "Then"
        ( Statement { ":" Statement } [ "Else" Statement { ":" Statement } ] EOL
        | MultilineIfRemainder
        )
    |    MultilineIfRemainder
    )
.

MultilineIfRemainder =
    StatementTerminatorAndBlock
    {
        ("Else" [ "If" Expression [ "Then" ] ]
        | "ElseIf" Expression [ "Then" ]
        )
        StatementTerminatorAndBlock
    }
    "End" "If"
.

SelectStatement =
	"Select" [ "Case" ] Expression StatementTerminator
	{
		"Case" (
			"Else" |
			( [ "Is" ] ComparisonOperator SimpleExpressionWithSuffix | Expression )
				{ "," ( [ "Is" ] ComparisonOperator SimpleExpressionWithSuffix | Expression ) }
		)
		StatementTerminatorAndBlock
	}
	"End" "Select"
.

ComparisonOperator =
	"=" | "<>" | "<" | ">" | ">=" | "<="
.

InvocationStatement =
	[ "Call" ] Expression
.

ArgumentList =
	Expression { "," Expression }
.

/* This production handles pseudo keywords that are needed in the grammar */
Identifier =
	(. PushContext(Context.IdentifierExpected, t); .)
	(
		IdentifierForFieldDeclaration
	|
		"Custom"
	)
	(. PopContext(); .)
.

IdentifierForFieldDeclaration =
	ident
	| "Aggregate"
	| "Ansi"
	| "Ascending"
	| "Assembly"
	| "Auto"
	| "Binary"
	| "By"
	| "Compare"
	| "Descending"
	| "Distinct"
	| "Equals"
	| "Explicit"
	| "From"
	| "Group"
	| "Infer"
	| "Into"
	| "Join"
	| "Key"
	| "Off"
	| "Order"
	| "Preserve"
	| "Skip"
	| "Take"
	| "Text"
	| "Unicode"
	| "Until"
	| "Where"
.

AccessModifier =
	"Public" |
	"Friend" |
	"Protected" |
	"Private"
.

TypeModifier =
	AccessModifier |
	"Shadows"
.

MemberModifier =
	AccessModifier |
	"Shadows" |
	"Shared" |
	"Overridable" |
	"NotOverridable" |
	"Overrides" |
	"Overloads" |
	"Partial" |
	"WithEvents" |
	"MustOverride" |
	"Widening" |
	"Narrowing" |
	"Dim"
.

ParameterModifier =
	"ByVal" |
	"ByRef" |
    "Optional" |
    "ParamArray"
.

END ExpressionFinder .