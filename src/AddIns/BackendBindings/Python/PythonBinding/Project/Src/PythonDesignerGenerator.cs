// <file>
//     <copyright see="prj:///doc/copyright.txt"/>
//     <license see="prj:///doc/license.txt"/>
//     <owner name="Matthew Ward" email="mrward@users.sourceforge.net"/>
//     <version>$Revision$</version>
// </file>

using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Collections;
using System.ComponentModel;
using System.Drawing;
using System.Reflection;
using System.Text;

using ICSharpCode.FormsDesigner;
using ICSharpCode.SharpDevelop;
using ICSharpCode.SharpDevelop.Dom;
using ICSharpCode.SharpDevelop.Gui;
using ICSharpCode.TextEditor;
using ICSharpCode.TextEditor.Document;
using IronPython.CodeDom;

namespace ICSharpCode.PythonBinding
{
	/// <summary>
	/// Form's designer generator for the Python language.
	/// </summary>
	public class PythonDesignerGenerator : IDesignerGenerator
	{
		readonly PythonProvider pythonProvider = new PythonProvider();
		FormsDesignerViewContent viewContent;
		
		public PythonDesignerGenerator()
		{
		}
		
		/// <summary>
		/// Gets the Python code dom provider.
		/// </summary>
		public CodeDomProvider CodeDomProvider {
			get { return pythonProvider; }
		}
		
		public void Attach(FormsDesignerViewContent viewContent)
		{
			this.viewContent = viewContent;
		}
		
		public void Detach()
		{
			this.viewContent = null;
		}
		
		public OpenedFile DetermineDesignerCodeFile()
		{
			return this.ViewContent.PrimaryFile;
		}
		
		/// <summary>
		/// Saves the changes made in the designer back to the source file.
		/// </summary>
		/// <param name="unit">The generated CodeCompileUnit. This
		/// is the code generated by the Windows Forms Designer.</param>
		public void MergeFormChanges(CodeCompileUnit unit)
		{
			GeneratedInitializeComponentMethod generatedInitalizeComponentMethod = GeneratedInitializeComponentMethod.GetGeneratedInitializeComponentMethod(unit);
			if (generatedInitalizeComponentMethod == null) {
				throw new InvalidOperationException("InitializeComponent not found in generated code.");				
			}
					                                               
			MergeFormChanges(generatedInitalizeComponentMethod);
		}
		
		/// <summary>
		/// Inserts an event handler.
		/// </summary>
		public bool InsertComponentEvent(IComponent component, EventDescriptor edesc, string eventMethodName, string body, out string file, out int position)
		{		
			// Ensure the text editor has the latest version
			// of the source code before we insert any new code.
			viewContent.MergeFormChanges();
			
			// Insert the event handler at the end of the class with an extra 
			// new line before it.
			IDocument doc = viewContent.DesignerCodeFileDocument;
			string eventHandler = CreateEventHandler(eventMethodName, body, "\t");
			string newContent = "\r\n" + eventHandler;
			int line = doc.LineSegmentCollection.Count;
			int offset = doc.GetLineSegment(line - 1).Offset;
			doc.Insert(offset, newContent);
			
			// Set position so it points to the line
			// where the event handler was inserted.
			position = line + 1;
	
			// Set the filename so it refers to the form being designed.
			file = viewContent.DesignerCodeFile.FileName;
			
			return true;
		}
		
		/// <summary>
		/// Returns a list of method names that could be used as an
		/// event handler with the specified event.
		/// </summary>
		public ICollection GetCompatibleMethods(EventDescriptor edesc)
		{
			// Get the form or user control class.
			ParseInformation parseInfo = ParseFile(this.ViewContent.DesignerCodeFile.FileName, this.ViewContent.DesignerCodeFileContent);
			
			// Look at the form's methods and see which are compatible.
			ArrayList methods = new ArrayList();
			IClass c = GetClass(parseInfo.BestCompilationUnit);
			foreach (IMethod method in c.Methods) {
				if (method.Parameters.Count == 2) {
					methods.Add(method.Name);
				}
			}
			
			return methods;
		}
		
		[Obsolete("This method is not used by the forms designer.")]
		public ICollection GetCompatibleMethods(EventInfo edesc)
		{
			return new ArrayList();
		}		
		
		/// <summary>
		/// Called by the MergeFormChanges method after the InitializeComponents
		/// method and associated class is found.
		/// </summary>
		protected virtual void MergeFormChanges(GeneratedInitializeComponentMethod generatedInitializeComponent)
		{
			ParseInformation parseInfo = ParseFile(this.ViewContent.DesignerCodeFile.FileName, this.ViewContent.DesignerCodeFileContent);
			generatedInitializeComponent.Merge(this.ViewContent.DesignerCodeFileDocument, parseInfo.BestCompilationUnit);
		}
		
		/// <summary>
		/// Returns the method body region that should be used
		/// when replacing the code in the text editor.
		/// </summary>
		protected DomRegion GetBodyRegionInDocument(IMethod method)
		{
			return GeneratedInitializeComponentMethod.GetBodyRegionInDocument(method);
		}
						
		/// <summary>
		/// Gets the view content attached to this generator.
		/// </summary>
		public FormsDesignerViewContent ViewContent {
			get { return viewContent; }
		}
		
		/// <summary>
		/// The default implementation calls the ParserService.ParseFile. This
		/// method is overridable so the class can be easily tested without
		/// the ParserService being required.
		/// </summary>
		protected virtual ParseInformation ParseFile(string fileName, string textContent)
		{
			return ParserService.ParseFile(fileName, textContent);
		}
		
		/// <summary>
		/// Returns the generated event handler.
		/// </summary>
		protected string CreateEventHandler(string eventMethodName, string body, string indentation)
		{			
			if (String.IsNullOrEmpty(body)) {
				body = "pass";
			}

			StringBuilder eventHandler = new StringBuilder();
			
			eventHandler.Append(indentation);
			eventHandler.Append("def ");
			eventHandler.Append(eventMethodName);
			eventHandler.Append("(self, sender, e):");
			eventHandler.AppendLine();
			eventHandler.Append(indentation);
			eventHandler.Append("\t");
			eventHandler.Append(body);
			
			return eventHandler.ToString();
		}
		
		/// <summary>
		/// Gets the form or user control class from the compilation unit.
		/// </summary>
		IClass GetClass(ICompilationUnit unit)
		{
			return unit.Classes[0];
		}
	}
}
