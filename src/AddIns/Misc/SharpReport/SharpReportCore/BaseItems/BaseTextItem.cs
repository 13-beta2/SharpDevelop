//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.2032
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------
using System;
using System.Drawing;
using System.ComponentModel;
using System.Xml.Serialization;	

using SharpReportCore;
	
/// <summary>
/// This class is the BaseClass  for all TextBased Items 
/// like <see cref="BaseDataItem"></see> etc.
/// </summary>


namespace SharpReportCore {
	
	public class BaseTextItem : SharpReportCore.BaseReportItem,IItemRenderer {
		private string text;

		private string formatString = String.Empty;
		private StringFormat stringFormat;
		private StringTrimming stringTrimming;
		private TextDrawer textDrawer = new TextDrawer();
		private ContentAlignment contentAlignment;
		
		#region Constructor
		public BaseTextItem():base() {
		this.stringFormat = StringFormat.GenericTypographic;
		this.contentAlignment = ContentAlignment.MiddleLeft;
		this.stringTrimming = StringTrimming.EllipsisCharacter;
		}
		
		#endregion
		
		private StringFormat BuildStringFormat(){
			StringFormat format = StringFormat.GenericTypographic;
			format.Trimming = this.stringTrimming;
			format.FormatFlags = StringFormatFlags.LineLimit;

//			if (base.RightToLeft)
//			{
//				format1.FormatFlags |= StringFormatFlags.DirectionRightToLeft;
//			}
			
			ContentAlignment alignment = this.contentAlignment;
			if (alignment <= ContentAlignment.MiddleCenter){
				switch (alignment){
					case ContentAlignment.TopLeft:{
							format.Alignment = StringAlignment.Near;
							format.LineAlignment = StringAlignment.Near;
							return format;
						}
					case ContentAlignment.TopCenter:{
							format.Alignment = StringAlignment.Center;
							format.LineAlignment = StringAlignment.Near;
							return format;
						}
					case (ContentAlignment.TopCenter | ContentAlignment.TopLeft):{
							return format;
						}
					case ContentAlignment.TopRight:{
							format.Alignment = StringAlignment.Far;
							format.LineAlignment = StringAlignment.Near;
							return format;
						}
					case ContentAlignment.MiddleLeft:{
							format.Alignment = StringAlignment.Near;
							format.LineAlignment = StringAlignment.Center;
							return format;
						}
					case ContentAlignment.MiddleCenter:{
							format.Alignment = StringAlignment.Center;
							format.LineAlignment = StringAlignment.Center;
							return format;
						}
				}
				return format;
			}
			if (alignment <= ContentAlignment.BottomLeft){
				if (alignment == ContentAlignment.MiddleRight){
					format.Alignment = StringAlignment.Far;
					format.LineAlignment = StringAlignment.Center;
					return format;
				}
				if (alignment != ContentAlignment.BottomLeft){
					return format;
				}
			}
			else{
				if (alignment != ContentAlignment.BottomCenter){
					if (alignment == ContentAlignment.BottomRight)
					{
						format.Alignment = StringAlignment.Far;
						format.LineAlignment = StringAlignment.Far;
					}
					return format;
				}
				format.Alignment = StringAlignment.Center;
				format.LineAlignment = StringAlignment.Far;
				return format;
			}
			format.Alignment = StringAlignment.Near;
			format.LineAlignment = StringAlignment.Far;
			return format;
		}
		
		
		public override void Render(ReportPageEventArgs rpea) {
			if (rpea == null) {
				throw new ArgumentNullException("rpea");
			}
			base.Render(rpea);
			RectangleF rect = PrepareRectangle (rpea,this.Text);
			PrintTheStuff (rpea,this.Text,rect);
			base.NotiyfyAfterPrint (rpea.LocationAfterDraw);
		}
		
		public override string ToString() {
			return "BaseTextItem";
		}
		
		private void Decorate (ReportPageEventArgs rpea,Rectangle border) {
			using (SolidBrush brush = new SolidBrush(base.BackColor)) {
				rpea.PrintPageEventArgs.Graphics.FillRectangle(brush,border);
			}
			if (base.DrawBorder == true) {
				using (Pen pen = new Pen(Color.Black, 1)) {
					rpea.PrintPageEventArgs.Graphics.DrawRectangle (pen,border);
				}
			}
		}
		
		protected RectangleF PrepareRectangle (ReportPageEventArgs e,string text) {
			SizeF measureSize = new SizeF ();
			measureSize = MeasureReportItem (e,text);			
			RectangleF rect = base.DrawingRectangle (e,measureSize);
			Decorate (e,System.Drawing.Rectangle.Ceiling (rect));
			return rect;
		}
		
		///<summary>
		/// Measure the Size of the String rectangle
		/// </summary>
		
		private SizeF MeasureReportItem (ReportPageEventArgs rpea,string text) {
			SizeF measureSizeF = new SizeF ();
			
			measureSizeF = rpea.PrintPageEventArgs.Graphics.MeasureString(text,
			                                                          this.Font,
			                                                          this.Size.Width,
			                                                          this.stringFormat);
			return measureSizeF;
		}
		
		/// <summary>
		/// Standart Function to Draw Strings
		/// </summary>
		/// <param name="e">ReportpageEventArgs</param>
		/// <param name="toPrint">Formatted String toprint</param>
		/// <param name="rectangle">rectangle where to draw the string</param>
	
		protected void PrintTheStuff (ReportPageEventArgs rpea,
		                              string toPrint,
		                              RectangleF rectangle ) {
			
			if (rpea == null) {
				throw new ArgumentException (this.Name);
			}
			StringFormat fmt = this.stringFormat;			
			textDrawer.DrawString(rpea.PrintPageEventArgs.Graphics,
			                      toPrint,
			                      this.Font,
			                      new SolidBrush(this.ForeColor),
			                      rectangle,
			                      fmt);

			rpea.LocationAfterDraw = new PointF (this.Location.X + this.Size.Width,
			                                  this.Location.Y + this.Size.Height);
		}
	
		///<summary>
		/// Formatstring like in MSDN
		/// </summary>
		[Browsable(true),
		 Category("Appearance"),
		 Description("String to format Number's Date's etc")]
		
		public virtual string FormatString {
			get {
				return formatString;
			}
			set {
				formatString = value;
				base.NotifyPropertyChanged("FormatString");
			}
		}
		
		
		public virtual string Text {
			get {
				return text;
			}
			set {
				text = value;
				base.NotifyPropertyChanged("Text");
			}
		}
		
		
		
		[Category("Appearance")]
		public StringTrimming StringTrimming {
			get {
				return stringTrimming;
			}
			set {
				stringTrimming = value;
				base.NotifyPropertyChanged("StringTrimming");
			}
		}
		
		[Category("Appearance")]
		public System.Drawing.ContentAlignment ContentAlignment {
			get {
				return this.contentAlignment;
			}
			set {
				this.contentAlignment = value;
				base.NotifyPropertyChanged("ContentAlignment");
			}
		}
		
		[Browsable(false)]
		[XmlIgnoreAttribute]
		public StringFormat StringFormat {
			get {
				return this.BuildStringFormat();
			}
		}
	}
}
