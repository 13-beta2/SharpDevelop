using System;
using System.Linq;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Windows;
using System.Windows.Input;
using SDCommandManager=ICSharpCode.Core.Presentation.SDCommandManager;


namespace ICSharpCode.Core.Presentation
{
	/// <summary>
	/// <see cref="BindingGroup" /> manages collection of instances which accept
	/// bindings generated by <see cref="CommandBindingInfo" /> or <see cref="InputBindingInfo" />
	/// 
	/// For <see cref="BindingGroup" /> to take effect it must be added to <see cref="InputBindingInfo.Groups" />
	/// or <see cref="CommandBindingInfo.Groups" /> collection
	/// </summary>
	public class BindingGroup
	{
		private string _name;
		private bool _isEnabled = true;
		private HashSet<WeakReference> _attachedInstances = new HashSet<WeakReference>(new WeakReferenceTargetEqualirtyComparer());
		private BindingGroupCollection _nestedGroups = new BindingGroupCollection();
		
		/// <summary>
		/// Creates new instance of <see cref="BindingGroup" />
		/// </summary>
		/// <param name="name">Group name</param>
		public BindingGroup(string name)
		{
			_name = name;
			_nestedGroups.CollectionChanged += _nestedGroups_CollectionChanged;
		}
		
		/// <summary>
		/// Gets <see cref="BindingGroup" /> name
		/// </summary>
		public string Name
		{
			get {
				return _name;
			}
		}
		
		/// <summary>
		/// Gets read-only collection of attached instances
		/// </summary>
		public ICollection<UIElement> RegisteredInstances
		{
			get {
				return new ReadOnlyCollection<UIElement>((from wr in _attachedInstances where wr.Target != null select (UIElement)wr.Target).ToList());
			}
		}
		
		/// <summary>
		/// Determines whether <see cref="UIElement" /> instance is handled by this group
		/// </summary>
		/// <param name="instance">Examined instance</param>
		/// <returns><code>true</code> if registered; otherwise <code>false</code></returns>
		public bool IsInstanceRegistered(UIElement instance) 
		{
			return _attachedInstances.Contains(new WeakReference(instance));
		}
		
		/// <summary>
		/// Register <see cref="UIElement" /> instance handled by this group
		/// </summary>
		/// <param name="instance">Registered instance</param>
		public void RegisterHandledInstance(UIElement instance)
		{
			RegisterHandledInstanceWithoutInvoke(instance);
			InvokeBindingUpdateHandlers(GetFlatNestedGroups(true), GetInstancesRegisteredInNestedGroups(true));
		}
		
		private void RegisterHandledInstanceWithoutInvoke(UIElement instance)
		{
			_attachedInstances.Add(new WeakReference(instance));
			
			foreach(var nestedGroup in _nestedGroups) {
				nestedGroup.RegisterHandledInstanceWithoutInvoke(instance);
			}
		}
		
		/// <summary>
		/// Gets single-level collection containing instances registered in this or any nested groups
		/// </summary>
		/// <param name="includeDisabledNestedGroups">Specifies whether binding groups with <see cref="BindingGroup.IsEnabled" /> attribute should be taken into account</param>
		public ICollection<UIElement> GetInstancesRegisteredInNestedGroups(bool includeDisabledNestedGroups)
		{
			var attachments = new HashSet<UIElement>();
			foreach(var group in GetFlatNestedGroups(includeDisabledNestedGroups)) {
				foreach(var groupAttachment in group.RegisteredInstances) {
					attachments.Add(groupAttachment);
				}
			}
			
			return new ReadOnlyCollection<UIElement>(attachments.ToArray());
		}
		
		/// <summary>
		/// Register <see cref="UIElement" /> instance handled by this group
		/// </summary>
		/// <param name="instance">Registered instance</param>
		public void UnregisterHandledInstance(UIElement instance)
		{
			var modifiedGroups = GetFlatNestedGroups(true);
			var modifiedInstances = GetInstancesRegisteredInNestedGroups(true);
			
			UnregisterHandledInstanceWithoutInvoke(instance);
			InvokeBindingUpdateHandlers(modifiedGroups, modifiedInstances);
		}
		
		
		/// <summary>
		/// Make <see cref="UIElement" /> instance no longer handled by this group
		/// </summary>
		/// <param name="instance">Unregistered instance</param>
		public void UnregisterHandledInstanceWithoutInvoke(UIElement instance)
		{
			_attachedInstances.Remove(new WeakReference(instance));
			
			foreach(var nestedGroup in _nestedGroups) {
				nestedGroup.UnregisterHandledInstance(instance);
			}
		}
		
		private void InvokeBindingUpdateHandlers(BindingGroupCollection modifiedGroups, ICollection<UIElement> modifiedInstances)
		{
			SDCommandManager.InvokeBindingsChanged(
				this, 
				new NotifyBindingsChangedEventArgs(
					NotifyBindingsChangedAction.GroupAttachmendsModified, 
					modifiedGroups,
					modifiedInstances));
		}
		
		/// <summary>
		/// From provided <see cref="ICollection{Type}" /> collection generate <see cref="ICollection{UIElement}" /> collection containing 
		/// instances created from one of the provided types and registered in this or any nested group
		/// </summary>
		/// <param name="instances">Collection of examined types</param>
		/// <param name="includeDisabledNestedGroups">Specifies whether binding groups with <see cref="BindingGroup.IsEnabled" /> attribute should be taken into account</param>
		/// <returns>Generated instances</returns>
		public ICollection<UIElement> FilterRegisteredInstances(ICollection<Type> types, bool includeDisabledNestedGroups)
		{
			var attachedInstances = new HashSet<UIElement>();
			foreach(var nestedGroup in GetFlatNestedGroups(includeDisabledNestedGroups)) {
				foreach(var wr in nestedGroup._attachedInstances) {
					var wrTarget = (UIElement)wr.Target;
					if(wrTarget != null && types.Any(t => t.IsInstanceOfType(wrTarget))) {
						attachedInstances.Add(wrTarget);
					}
				}
			}
			
			return attachedInstances;
		}
		
		/// <summary>
		/// From provided <see cref="ICollection{UIElement}" /> collection filter <see cref="ICollection{UIElement}" /> collection containing 
		/// only instances registered in this or one of the nested groups
		/// </summary>
		/// <param name="instances">Collection of examined instances</param>
		/// <param name="includeDisabledNestedGroups">Specifies whether binding groups with <see cref="BindingGroup.IsEnabled" /> attribute should be taken into account</param>
		/// <returns>Filtered instances</returns>
		public ICollection<UIElement> FilterRegisteredInstances(ICollection<UIElement> instances, bool includeDisabledNestedGroups)
		{
			var attachedInstances = new HashSet<UIElement>();
			foreach(var nestedGroup in GetFlatNestedGroups(includeDisabledNestedGroups)) {
				foreach(var wr in nestedGroup._attachedInstances) {
					var wrTarget = (UIElement)wr.Target;
					if(wrTarget != null && instances.Contains(wrTarget)) {
						attachedInstances.Add(wrTarget);
					}
				}
			}
			
			return attachedInstances;
		}
		
		/// <summary>
		/// Gets or sets value indicating whether whole group is enabled
		/// </summary>
		public bool IsEnabled {
			get {
				return _isEnabled;
			}
			set {
				_isEnabled = value;
				
				InvokeBindingUpdateHandlers(new BindingGroupCollection(true, new [] { this }), GetInstancesRegisteredInNestedGroups(true));
			}
		}
		
		/// <summary>
		/// Gets direct sub-groups of this groups
		/// </summary>
		public BindingGroupCollection NestedGroups
		{
			get {
				return _nestedGroups;
			}
		}
		
		/// <summary>
		/// Gets single-level collection containing this group and all sub-groups of this group
		/// </summary>
		/// <param name="includeDisabledNestedGroups">Specifies whether binding groups with <see cref="BindingGroup.IsEnabled" /> attribute should be taken into account</param>
		public BindingGroupCollection GetFlatNestedGroups(bool includeDisabledNestedGroups)
		{
			var foundNestedGroups = new HashSet<BindingGroup>();
			FlattenNestedGroups(this, true, foundNestedGroups);
			
			return new BindingGroupCollection(true, foundNestedGroups);
		}
		
		private void FlattenNestedGroups(BindingGroup rootGroup, bool includeDisabledNestedGroups, HashSet<BindingGroup> foundGroups)
		{
			if(!includeDisabledNestedGroups && !IsEnabled) {
				return;
			}
			
			foundGroups.Add(rootGroup);
			
			foreach(var nestedGroup in NestedGroups) {
				if(foundGroups.Add(nestedGroup)) {
					FlattenNestedGroups(nestedGroup, includeDisabledNestedGroups, foundGroups);
				}
			}
		}
		
		private void _nestedGroups_CollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
		{
			var modifiedGroups = new BindingGroupCollection();
			modifiedGroups.AddRange(GetFlatNestedGroups(true));
			
			if(e.OldItems != null) {
				modifiedGroups.AddRange(e.OldItems.Cast<BindingGroup>());
			}
			
			var modifiedInstances = modifiedGroups.GetInstancesRegisteredInNestedGroups(true);
			
			InvokeBindingUpdateHandlers(modifiedGroups, modifiedInstances);
		}
    }
}
