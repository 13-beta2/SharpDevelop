using System;
using System.Linq;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Windows;
using System.Windows.Input;
using SDCommandManager=ICSharpCode.Core.Presentation.CommandManager;


namespace ICSharpCode.Core.Presentation
{
	/// <summary>
	/// <see cref="BindingGroup" /> manages collection of instances which accept
	/// bindings generated by <see cref="CommandBindingInfo" /> or <see cref="InputBindingInfo" />
	/// 
	/// For <see cref="BindingGroup" /> to take effect it must be added to <see cref="InputBindingInfo.Groups" />
	/// or <see cref="CommandBindingInfo.Groups" /> collection
	/// </summary>
	public class BindingGroup
	{
		private string _name;
		private HashSet<WeakReference> _attachedInstances = new HashSet<WeakReference>(new WeakReferenceEqualirtyComparer());
		private BindingGroupCollection _nestedGroups = new BindingGroupCollection();
		
		/// <summary>
		/// Creates new instance of <see cref="BindingGroup" />
		/// </summary>
		/// <param name="name">Group name</param>
		public BindingGroup(string name)
		{
			_name = name;
		}
		
		/// <summary>
		/// Gets <see cref="BindingGroup" /> name
		/// </summary>
		public string Name
		{
			get {
				return _name;
			}
		}
		
		/// <summary>
		/// Determines whether <see cref="UIElement" /> instance is handled by this group
		/// </summary>
		/// <param name="instance">Examined instance</param>
		/// <returns><code>true</code> if registered; otherwise <code>false</code></returns>
		public bool IsInstanceRegistered(UIElement instance) 
		{
			foreach(var nestedGroup in FlatNestedGroups) {
				if(nestedGroup._attachedInstances.Contains(new WeakReference(instance))) {
					return true;
				}
			}
			
			return false;
		}
		
		/// <summary>
		/// Register <see cref="UIElement" /> instance handled by this group
		/// </summary>
		/// <param name="instance">Registered instance</param>
		public void RegisterHandledInstance(UIElement instance)
		{
			RegisterHandledInstanceWithoutInvoke(instance);
			InvokeBindingUpdateHandlers(instance, true);
		}
		
		private void RegisterHandledInstanceWithoutInvoke(UIElement instance)
		{
			_attachedInstances.Add(new WeakReference(instance));
			
			foreach(var nestedGroup in _nestedGroups) {
				nestedGroup.RegisterHandledInstanceWithoutInvoke(instance);
			}
		}
		
		/// <summary>
		/// Register <see cref="UIElement" /> instance handled by this group
		/// </summary>
		/// <param name="instance">Registered instance</param>
		public void UnregisterHandledInstance(UIElement instance)
		{
			UnregisterHandledInstanceWithoutInvoke(instance);
			InvokeBindingUpdateHandlers(instance, false);
		}
		
		
		/// <summary>
		/// Make <see cref="UIElement" /> instance no longer handled by this group
		/// </summary>
		/// <param name="instance">Unregistered instance</param>
		public void UnregisterHandledInstanceWithoutInvoke(UIElement instance)
		{
			_attachedInstances.Remove(new WeakReference(instance));
			
			foreach(var nestedGroup in _nestedGroups) {
				nestedGroup.UnregisterHandledInstance(instance);
			}
		}
		
		private void InvokeBindingUpdateHandlers(UIElement instance, bool attaching)
		{
			SDCommandManager.InvokeBindingsChanged(
				this, 
				new NotifyBindingsChangedEventArgs(
					NotifyBindingsChangedAction.GroupAttachmendsModified, 
					FlatNestedGroups, 
					new []{instance}));
		}
		
		/// <summary>
		/// From provided <see cref="ICollection{Type}" /> generate <see cref="ICollection{UIElement}" /> containing 
		/// instances of any of the provided types and registered in this or any nested group
		/// </summary>
		/// <param name="instances">Collection of examined types</param>
		/// <returns>Generated instances</returns>
		public ICollection<UIElement> FilterAttachedInstances(ICollection<Type> types)
		{
			var attachedInstances = new HashSet<UIElement>();
			foreach(var nestedGroup in FlatNestedGroups) {
				foreach(var wr in nestedGroup._attachedInstances) {
					var wrTarget = (UIElement)wr.Target;
					if(wrTarget != null && types.Any(t => t.IsInstanceOfType(wrTarget))) {
						attachedInstances.Add(wrTarget);
					}
				}
			}
			
			return attachedInstances;
		}
		
		/// <summary>
		/// From provided <see cref="ICollection{UIElement}" /> filter <see cref="ICollection{UIElement}" /> containing 
		/// only instances registered in this or one of the nested groups
		/// </summary>
		/// <param name="instances">Collection of examined instances</param>
		/// <returns>Filtered instances</returns>
		public ICollection<UIElement> GetAttachedInstances(ICollection<UIElement> instances)
		{
			var attachedInstances = new HashSet<UIElement>();
			foreach(var nestedGroup in FlatNestedGroups) {
				foreach(var wr in nestedGroup._attachedInstances) {
					var wrTarget = (UIElement)wr.Target;
					if(wrTarget != null && instances.Contains(wrTarget)) {
						attachedInstances.Add(wrTarget);
					}
				}
			}
			
			return attachedInstances;
		}
		
		/// <summary>
		/// Gets direct sub-groups of this groups
		/// </summary>
		public BindingGroupCollection NestedGroups
		{
			get {
				return _nestedGroups;
			}
		}
		
		/// <summary>
		/// Gets all sub-groups of this group flattened into single level <see cref="BindingGroupCollection" />
		/// </summary>
		public BindingGroupCollection FlatNestedGroups
		{
			get {
				var foundNestedGroups = new HashSet<BindingGroup>();
				FlattenNestedGroups(this, foundNestedGroups);
				
				var groups = new BindingGroupCollection();
				groups.AddRange(foundNestedGroups);
				return groups;
			}
		}
		
		/// <summary>
		/// Flatten nested sub-groups from all level into single-lever <see cref="BindingGroupColletion" />
		/// </summary>
		/// <param name="rootGroup">Root group</param>
		/// <param name="foundGroups">Collection of already flattened groups</param>
		internal void FlattenNestedGroups(BindingGroup rootGroup, HashSet<BindingGroup> foundGroups)
		{
			foundGroups.Add(rootGroup);
			
			foreach(var nestedGroup in NestedGroups) {
				if(foundGroups.Add(nestedGroup)) {
					FlattenNestedGroups(nestedGroup, foundGroups);
				}
			}
		}
    }
}
